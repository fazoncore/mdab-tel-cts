# MDAB‑TEL — v0.1.1 Fixtures Manifest (PUBLIC‑SAFE)

**Purpose:** provide a minimal, high‑signal fixture set that closes determinism + equivocation gaps.
This is written as a manifest you can paste into `FIXTURES/README.md`.

> Replace placeholder hashes with actual expected values once generated by your verifier.

---

## Conventions
- Each fixture MUST declare an expected outcome: `PASS` or `FAIL_CLOSED`.
- For PASS fixtures, record the expected `scope_hash_sha256` (or relevant digest).
- For FAIL fixtures, record an expected error class / reason code (if your tool emits it), otherwise just `FAIL_CLOSED`.

---

## P0 — Determinism & parsing edge cases

### F‑UNICODE‑01 (NFC equivalence)
- **Files:**
  - `fixtures/v0.1.1/unicode_nfc_composed.json`
  - `fixtures/v0.1.1/unicode_nfc_decomposed.json`
- **Goal:** both inputs MUST canonicalize to the same bytes and produce identical scope hashes.
- **Expected:** both PASS and hashes identical.

### F‑UNICODE‑KEY‑01 (NFC key collision → duplicate keys)
- **File:** `fixtures/v0.1.1/unicode_key_collision.json`
- **Goal:** object contains two member names that differ only by Unicode normalization (e.g., composed vs decomposed), which become equal after NFC.
- **Expected:** FAIL_CLOSED (duplicate key after NFC normalization).

### F‑NUM‑01 (integer allowed)
- **File:** `fixtures/v0.1.1/num_integer_ok.json`
- **Expected:** PASS, record scope hash.

### F‑NUM‑02 (float forbidden)
- **File:** `fixtures/v0.1.1/num_float_forbidden.json`
- **Expected:** FAIL_CLOSED.

### F‑NUM‑03 (scientific notation forbidden)
- **File:** `fixtures/v0.1.1/num_scientific_forbidden.json`
- **Expected:** FAIL_CLOSED.

### F‑NUM‑04 (-0 forbidden)
- **File:** `fixtures/v0.1.1/num_negative_zero_forbidden.json`
- **Expected:** FAIL_CLOSED.

### F‑JSON‑01 (duplicate keys forbidden)
- **File:** `fixtures/v0.1.1/dup_keys_forbidden.raw.json`
- **Notes:** this must be tested as raw JSON text (parser must detect duplicates).
- **Expected:** FAIL_CLOSED.

### F‑SCHEMA‑01 (unknown field forbidden)
- **File:** `fixtures/v0.1.1/unknown_field_forbidden.json`
- **Expected:** FAIL_CLOSED.

---

## P0 — Hash scope & equivocation

### F‑SCOPE‑01 (event_type domain separation)
- **Files:**
  - `fixtures/v0.1.1/scope_event_type_A.json`
  - `fixtures/v0.1.1/scope_event_type_B.json`
- **Goal:** identical payload but different `event_type/schema_id` MUST produce different hashes.
- **Expected:** both PASS, hashes MUST differ.

### F‑CHAIN‑01 (missing link)
- **Files:**
  - `fixtures/v0.1.1/chain_valid_3.jsonl`
  - `fixtures/v0.1.1/chain_missing_middle.jsonl`
- **Goal:** removing a middle record MUST break verification.
- **Expected:** valid chain PASS; missing‑middle FAIL_CLOSED.

---

## P1 — Signature semantics (if enabled)

### F‑SIG‑01 (valid signature)
- **File:** `fixtures/v0.1.1/sig_valid.json`
- **Expected:** PASS.

### F‑SIG‑02 (tampered signature)
- **File:** `fixtures/v0.1.1/sig_tampered.json`
- **Expected:** FAIL_CLOSED.

---

## P2 — Sequence / envelope coherence (roadmap; optional)

> This section does **not** change v0.1.x semantics. It is an optional roadmap fixture set for a future “envelope checkpoint” profile.

### F‑ENV‑01 (checkpoint catches composed invariant violation)
- **Files (suggested):**
  - `fixtures/v0.1.1/env_decisions_locally_conformant.jsonl`
  - `fixtures/v0.1.1/env_invariant_declaration.json`
  - `fixtures/v0.1.1/env_checkpoint_boundary_fail.json`
- **Goal:** each individual decision is locally conformant (Audit PASS), but a **system‑level invariant** fails at a named checkpoint boundary.
- **Expected:** decisions PASS; checkpoint evaluation yields **NONCONFORMANT / FAIL_CLOSED** at the envelope layer; checkpoint result references the correct `invariant_hash`.
- **Reviewer intent:** creates a discrete audit surface (“boundary X”) that is easier to certify than auditing a rolling stream.


## Minimal fixture payload examples (copy/paste starters)

### unicode_nfc_composed.json
```json
{
  "spec_version": "0.1.x",
  "event_type": "fixture",
  "payload": { "text": "café" }
}
```

### unicode_nfc_decomposed.json
*(same JSON, but the `é` is decomposed: `e` + combining accent; store as UTF‑8)*
```json
{
  "spec_version": "0.1.x",
  "event_type": "fixture",
  "payload": { "text": "café" }
}
```

### num_float_forbidden.json
```json
{
  "spec_version": "0.1.x",
  "event_type": "fixture",
  "payload": { "n": 1.0 }
}
```

### dup_keys_forbidden.raw.json
```json
{ "a": 1, "a": 2 }
```
